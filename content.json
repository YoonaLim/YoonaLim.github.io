{"meta":{"title":"March 30th,1995","subtitle":null,"description":"In carnage,I bloom,like a flower in the dawn.","author":"maijiaGod","url":"https://yoonalim.github.io","root":"/"},"pages":[{"title":"All categories","date":"2018-01-11T03:49:00.000Z","updated":"2018-01-12T02:23:48.000Z","comments":true,"path":"categories/index.html","permalink":"https://yoonalim.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tagcloud","date":"2018-01-11T03:51:24.000Z","updated":"2018-01-12T02:38:32.000Z","comments":true,"path":"tags/index.html","permalink":"https://yoonalim.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++自学记录","slug":"c++自学记录","date":"2022-08-26T02:10:54.000Z","updated":"2022-08-30T06:06:24.000Z","comments":true,"path":"2022/08/26/c++自学记录/","link":"","permalink":"https://yoonalim.github.io/2022/08/26/c++%E8%87%AA%E5%AD%A6%E8%AE%B0%E5%BD%95/","excerpt":"","text":"用来记录学习c++的历程~ 2022年08月26日 Day1：环境搭建 安装gcc和cmake 不知道该用什么IDE,先试试clion 看了看菜鸟教程,找了下学习路线 Day2：qt学习 因为公司技术选型qt所以先了解qt IDE尝试了clion和QtCreater发现想用qt还是得QtCreater。 优点一:编译方便,简单项目不需要自己去写CMakeList并且主动提供了DeBug、Profile、Release三种编译策略,完全不需要配置。顾名思义这三者为调试、平衡、发布版本。 优点二: QtCreater自动生成的.pro文件方便管理项目。很多基础配置都可以更简便的实现。 优点三:更方便的集成QtDesign。clion如果想可视化编辑ui,需要配置外部工具,这个外部工具大概率就是QtDesign,而QtCreater直接集成了QtDesign,谁也不想开发时还要打开多个IDE吧。 那问题就简化了，首先要了解QtCreater 犹豫不决Hello World!先运行起来再说。 了解.pro文件,其实可以发现,有点像pom文件,感觉可以类比着理解,如果后续发现不同再来更新。 试着给程序加上图标。 生成图标步骤: 新建一个文件夹XXX.iconset 把图标文件放到这个文件夹里,png格式。eg:logo.png 执行 1234567891011121314151617sips -z 16 16 logo.png --out icon_16.pngsips -z 16 16 logo.png --out icon_16@2x.pngsips -z 32 32 logo.png --out icon_32.pngsips -z 32 32 logo.png --out icon_32@2x.pngsips -z 64 64 logo.png --out icon_64.pngsips -z 64 64 logo.png --out icon_64@2x.pngsips -z 128 128 logo.png --out icon_128.pngsips -z 128 128 logo.png --out icon_128@2x.pngsips -z 256 256 logo.png --out icon_256.pngsips -z 256 256 logo.png --out icon_256@2x.pngsips -z 512 512 logo.png --out icon_512.pngsips -z 512 512 logo.png --out icon_512@2x.png 生成16到512像素的图标。 回到上级文件夹执行iconutil -c icns logo.iconset 在.pro文件添加ICON = ./xxx.icns重新编译。 这里要吐槽一下macos,生成图标太复杂了…Windows直接用.icon就可以。 初步认识“信号(signal)和槽(slot)” 信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种发出是没有目的的，类似广播。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，当信号发出时，被连接的槽函数会自动被回调。信号和槽是Qt非常核心的内容，可以说如果不会灵活使用信号和槽，那么使用Qt也就失去了意义。","categories":[{"name":"log","slug":"log","permalink":"https://yoonalim.github.io/categories/log/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://yoonalim.github.io/tags/C/"}]},{"title":"Java实现SSO单点登录","slug":"Java实现SSO单点登录","date":"2019-02-15T07:11:51.000Z","updated":"2022-08-29T01:27:51.195Z","comments":true,"path":"2019/02/15/Java实现SSO单点登录/","link":"","permalink":"https://yoonalim.github.io/2019/02/15/Java%E5%AE%9E%E7%8E%B0SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/","excerpt":"","text":"什么是SSOSSO（Single Sign On）单点登录是实现多个系统之间统一登录的验证系统，简单来说就是：有A，B，C三个系统，在A处登录过后，再访问B系统，B系统就已经处于了登录状态，C系统也是一样。举个生活中栗子：你同时打开天猫和淘宝，都进入login界面，都要求你登录的，现在你在淘宝处登录后，直接在天猫处刷新，你会发现，你已经登录了，而且就是你在淘宝上登录的用户。说明他们实现了SSO，并且持有相同的信息。 当然这个特性意味着它的使用场景是：同一公司下的不同子系统，因为对于SSO来说，每一个子系统拥有的信息都一样，是用户的全部信息，如果是不同公司，那这肯定不合适。现在的天猫和淘宝就是这样的一套SSO。 实现思想SSO简单来说就是一句话：一处登录，全部访问。 现在有两个系统分别是：a.com和b.com，我们要实现他们的SSO，那么我们就需要一个统一验证中心sso.com，我们所有的登录和身份验证都在sso.com中操作。看图看传统登录方式和SSO方式的差别如下： 我们需要将统一信息存在cookie中。 登录部分：在用户第一次访问a.com时，到达a.com的服务器，服务器请求sso.com&#x2F;ssocheck验证，验证失败，a.com的服务器到达login界面，用户在login界面输入用户名和密码，到达a.com的服务器，请求sso.com&#x2F;login验证，验证通过生成token（包括用户登录信息），然后携带token和所有子系统路径返回a.com的服务器，a.com的服务器到达首页，同时请求自己和所有子系统的addcookie方法，将token添加到自己的cookie中。 在用户访问b.com时，同样向sso.com&#x2F;check发出验证cookie请求，sso验证token，验证成功返回到b.com的服务器，然后到达b的首页显示登录成功。 退出部分：用户点击a.com的退出按钮，访问sso.com&#x2F;loginout，然后获得所有子系统信息，请求所有子系统clearcookie方法，并重定向到login界面。 跨域部分：看下登录（退出就不看了，登录写出来后退出就很简单了）的流程图： 代码实现用户访问a.com，用户先验证cookie到达a.com/ssocheck 1234567891011121314151617181920212223242526/** * * @return 响应界面：login/index */ @GetMapping(&quot;/ssocheck&quot;) public ModelAndView checkCookies (HttpServletRequest request) &#123; Cookie[] cookies = request.getCookies(); if (cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for (Cookie cookie : cookies) &#123; if (&quot;exp&quot;.equals(cookie.getName())) &#123; //统一登录cookie为exp，如果存在就认证 log.info(&quot;cookie 存在，开始验证&quot;); HttpUtil httpUtil = new HttpUtil(&quot;http://sso.com/sso/authcookies&quot;, Method.GET); String result = httpUtil.send(cookie.getName(), cookie.getValue()); boolean authBoo = Boolean.valueOf(result); if (authBoo) &#123; log.info(&quot;验证通过&quot;); return new ModelAndView(&quot;public/index&quot;); &#125; break; &#125; &#125; &#125; return new ModelAndView(&quot;index&quot;); &#125; 在判断中，如果a.com中有名为exp的cookie，那么就去sso.com/sso/authcookies去认证cookievalue，那么在sso.com中方法是这样的： 12345678910111213141516/** * 验证cookie是否通过 * @param cookieName cookie名称 * @param cookieValue cookie内容 * @return 是否认证成功 */@GetMapping(&quot;/authcookies&quot;)public boolean checkAuthCookies (String cookieName, String cookieValue) &#123; boolean isUpdate = new JwtUtil(null,cookieValue).freeJwt(); if (&quot;exp&quot;.equals(cookieName) &amp;&amp; &quot;ok&quot;.equals(cookieValue)) &#123; log.info(&quot;cookie验证通过&quot;); return true; &#125; return false;&#125; 这里用到了HttpHelpler类，这是我自己封装的，先说正事，这个工具类下面再放它，不要打扰了主线。如果认证cookie通过，那么说明已经在别的系统处登录过了，然后a.com就返回到首页，如果认证失败，a.com就到达登录页面，在我例子这是分别是public&#x2F;index和index界面。 登录界面就不亮了，很简单，就两个输入框，输入用户名和密码，然后提交到a.com/login，然后看下这个方法 123456789101112131415161718192021222324/** * 登录 * @param username 用户名 * @param password 密码 * @return index/login */@PostMapping(&quot;/login&quot;)public ModelAndView doLogin (String username, String password) &#123; if (username != null &amp;&amp; !&quot;&quot;.equals(username) &amp;&amp; password != null &amp;&amp; !&quot;&quot;.equals(password) ) &#123; HttpHelpler httpUtil = new HttpHelpler(&quot;http://sso.com/sso/&quot;, &quot;POST&quot;); Result result = httpUtil.sendLogin(username,password); //如果验证通过，就携带所有子系统域名返回首页 int isLogin = result.getResultCode().getCode(); if (isLogin == 1) &#123; @SuppressWarnings(&quot;all&quot;) Map&lt;String,String&gt; param = (Map&lt;String, String&gt;) result.getData(); return new ModelAndView(&quot;public/index&quot;,&quot;sendparam&quot;,param); &#125; &#125; return new ModelAndView(&quot;index&quot;);&#125; 在a.com处请求sso.com/sso验证 123456789101112131415161718192021222324252627282930/** * 统一处理login请求 * @param username 用户名 * @param password 密码 */@PostMappingpublic Result&lt;Map&lt;String,Object&gt;&gt; checkLogin (String username, String password) &#123; log.info(&quot;统一登录校验&quot;); TbUser user = userService.login(username, password); if (user != null) &#123; //封装参数 Map&lt;String, Object&gt; param = new HashMap&lt;&gt;(); //获得所有子系统域名信息 List&lt;TbDomain&gt; domains = domainService.selectAll(); List&lt;String&gt; domainUrl = new ArrayList&lt;&gt;(domains.size()); domains.forEach(domain-&gt;&#123; domainUrl.add(domain.getDomain()+&quot;/addcookie&quot;); &#125;); //生成jwt，加密用户信息 String cookieName = &quot;exp&quot;; String cookieValue = new JwtUtil(user.toString(),null).creatJwt(); param.put(&quot;cookieurl&quot;,domainUrl); param.put(&quot;cookieName&quot;, cookieName); param.put(&quot;cookieValue&quot;,cookieValue); Result&lt;Map&lt;String, Object&gt;&gt; result = new Result&lt;&gt;(ResultCodeEnum.AUTHSUCCESS); result.setData(param); return result; &#125; return new Result&lt;&gt;(ResultCodeEnum.UNAUTHORIZEd,&quot;账号或密码错误&quot;);&#125; 在这里如果验证失败就返回账号或密码错误，如果验证通过，就得到所有域名，然后加密当前用户信息，用到了jwt（json web token，不做过多讲解），然后返回a.com。在a.com发现验证通过就到达首页，验证失败继续到达登录，在首页要使用ajax循环访问所有子系统，将cookie信息添加到所有子系统下。 然后在此访问所有子系统的/addcookie方法，这里涉及到跨域，可以看到，我跨域使用的是ajax的json方式，中间还遇到了一些异常，总之解决掉了。 看下a.com/addcookie方法 123456789101112131415/** * * @param cookieName cookie名称 * @param cookieValue cookie值 * @param response 响应 */ @GetMapping(&quot;/addcookie&quot;) public void addCookies (String cookieName, String cookieValue, HttpServletResponse response) &#123; log.info(&quot;添加cookie&quot;); Cookie cookie = new Cookie(cookieName,cookieValue); cookie.setPath(&quot;/&quot;); cookie.setMaxAge(3600); cookie.setHttpOnly(true); response.addCookie(cookie); &#125; 然后这时候查看下浏览器的cookie就会发现已经为它写上了，访问b.com/ssocheck就会直接通过，b.com下也被写了cookie。 看下退出，退出就简便多了。 首先在a.com首页点击退出按钮，然后触发js，访问sso.com/logout方法。 123456789101112131415161718192021222324252627//退出登录，清空所有子系统的cookie $(&quot;#loginout&quot;).click (function (event) &#123; $.ajax(&#123; url: &quot;http://sso.com/sso/loginout&quot;, type: &quot;get&quot;, jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(默认为:callback) jsonpCallback:&quot;success_jsonpCallback&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名 dataType: &quot;jsonp&quot;, //指定服务器返回的数据类型 success: function (data) &#123; window.location.href=&quot;/loginout&quot;; eachUrl(data);//循环清理掉所有子系统cookie &#125;,error:function (data) &#123; console.log(data.jqXHR+&quot; &quot;+data.status+&quot; &quot;+data.error); &#125; &#125;); &#125;); function eachUrl(arrDomain) &#123; jQuery.each(arrDomain, function () &#123; // this 指定值 //循环访问 $.ajax(&#123; url: this, type: &quot;get&quot;, dataType: &quot;jsonp&quot; //指定服务器返回的数据类型 &#125;); &#125;); &#125; 会去访问sso.com/loginout方法，拿到所有域名清除cookie方法。 123456789101112131415/** * 添加需要清除的cookie */ @GetMapping(&quot;/loginout&quot;) public String loginOut (HttpServletRequest request) &#123; String callbackFuncation = request.getParameter(&quot;callback&quot;); log.info(&quot;start clear&quot;); List&lt;TbDomain&gt; domains = domainService.selectAll(); List&lt;String&gt; domainUrl = new ArrayList&lt;&gt;(domains.size()); domains.forEach(domain-&gt;&#123; domainUrl.add(domain.getDomain()+&quot;/clear&quot;); &#125;); String resultMsg = JSON.toJSONString(domainUrl); return callbackFuncation+&quot;(&quot;+resultMsg+&quot;)&quot;; &#125; 然后拿到后，首先会自己跳回到登录界面，然后再去请求其他子系统的清除cookie方法，防止请求时间过长无法给用户响应。看下清除cookie方法。 123456789101112131415161718/** * 清除掉cookie * @param request 请求 * @param response 响应 */ @GetMapping(&quot;/clear&quot;) public void clear (HttpServletRequest request,HttpServletResponse response) &#123; //获得域名 log.info(&quot;clear掉ip为：&quot;+request.getRemoteHost()+&quot;的cookie&quot;); Cookie [] cookies = request.getCookies(); for (Cookie cookie: cookies) &#123; if (&quot;wlgzs&quot;.equals(cookie.getName())) &#123; cookie.setValue(null); cookie.setMaxAge(0); response.addCookie(cookie); &#125; &#125; &#125; 然后再去访问刚才还能访问的b.com就会发现验证失败返回到登录界面，它的cookie也被清除了。","categories":[{"name":"basic","slug":"basic","permalink":"https://yoonalim.github.io/categories/basic/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://yoonalim.github.io/tags/Java/"}]},{"title":"LeBron James career","slug":"LeBron James career","date":"2018-12-19T01:56:35.000Z","updated":"2022-08-29T01:26:53.213Z","comments":true,"path":"2018/12/19/LeBron James career/","link":"","permalink":"https://yoonalim.github.io/2018/12/19/LeBron%20James%20career/","excerpt":"","text":"初入联盟2003-2004赛季2002年2月18日，高三的勒布朗作为”The Chosen one”首次登上体育画报封面。 2003年6月26日的NBA选秀会上以第一轮第一顺位被克利夫兰骑士选中。 这也是全联盟甚至全美都在等待的一刻。可以说全美都在等待着勒布朗登陆NBA。早在高中时就被赋予了“King James”的绰号。在登陆NBA的第一分钟前，十几岁的勒布朗就获得了1.42亿美元的代言。 David Stern:“很明显，他们(耐克)在这个年轻人身上豪赌” 2003年10月29日，生涯的第一场比赛面对萨克拉门托国王，取得25分、6篮板、9助攻及60%的投篮命中率（20投12中）。 勒布朗的首秀吸引了无数人的目光。这场比赛在本赛季ESPN转播的69场比赛中收视率第二，排在第一的是“大鲨鱼”奥尼尔与“小巨人”姚明的对决。 2003年11月29日，面对曼菲斯灰熊，攻下33分，成为NBA史上最年轻达成单场30分的球员（18岁334天）。 2004年3月27日，对阵新泽西篮网，取得41分，成为NBA史上最年轻达成单场40分的球员（19岁88天）。 这个赛季骑士的成绩是35胜47负，比上季多赢得18场比赛，未能进季后赛。但勒布朗的表现已经震惊了联盟，越来越多的讨论开始围绕着这个新秀展开。 聚光灯没有暗下去，反而愈加刺眼 2004-2005赛季2005年1月19日，对阵波特兰开拓者队，全场攻下27分、11篮板、10助攻，完成个人职业生涯的第一次“三双”。 2005年2月20日，勒布朗·詹姆斯生涯首次入选为NBA明星队赛东部首发球员，缴出13分、8篮板、6助攻，最后东部明星队以125-115击败西部明星队。艾弗森获得全明星MVP。 2005年3月20日，对阵多伦多猛龙，攻下个人生涯单场最高的56分，也成为NBA史上最年轻单场得到50分的球员（20岁80天），不过此纪录已在2009年11月14日被布兰登·詹宁斯的20岁52天所改写。 这个赛季骑士队取得了42胜40负的战绩，虽与篮网队战绩相同，但因两队胜负关系，骑士无缘季后赛。 虽然球队还在挣扎，但勒布朗交出了27+7+7并且场均2.2次抢断的答卷，这个二年级生已然成为了克城的希望。 2005-2006赛季2006年2月19日，勒布朗·詹姆斯再次入选明星队赛东部首发，送出29分、6篮板、2助攻的表现，协助东部明星队以122-120击败西部明星队，赛后勒布朗·詹姆斯获选为明星赛MVP，以21岁51天成为史上最年轻的明星赛最有价值球员。 2006年3月22日-4月8日，勒布朗连续九场比赛得分在35分以上，自1970年代起，只有迈克尔·乔丹及科比·布莱恩特才能达成这项记录。 勒布朗在本赛季平均取得31.4分、7.0篮板、6.6助攻，成为NBA史上最年轻达成单季平均超过30分的球员（21岁107天）。同时，他也是史上第四位单季平均在30分、7篮板及6助攻以上的球员。 骑士队本季战绩50胜32败，以东部第四种子晋级季后赛，也是1998年以来首次晋级，首轮将遇到华盛顿奇才队。 2006年4月22日，勒布朗在生涯的第一场季后赛取得32分、11篮板、11助攻的“三双”，骑士队也以97-86击败对手，他是继约翰尼·麦卡锡及魔术师约翰逊后，第三位在生涯首场季后赛中取得三双的球员，最终骑士六场比赛将奇才淘汰。勒布朗在季后赛平均攻下30.8分、8.1篮板、5.8助攻。不过在第二轮，骑士即被底特律活塞淘汰出局。 在进入联盟时勒布朗就说过一定会为克城带来冠军，至此，没有人会质疑，克城球迷追寻着一道光，翘首以盼自己的第一个冠军。 而这只是勒布朗的第三个赛季。 渐入佳境2006-2007赛季2007年2月18日，勒布朗·詹姆斯连续第三年获选为明星赛东部首发前锋，他取得28分、6个篮板及6次助攻，但最后东部以132比153不敌西部。科比·布莱恩特获得全明星MVP。 此赛季骑士队以50胜32败的成绩成为东部第二种子晋级季后赛。首轮直落4局横扫华盛顿奇才。 第二轮遇到的对手是新泽西篮网队，骑士队第六战在客场88比72大胜对手，4-2将新泽西篮网淘汰出局，这也是骑士队自1992年以后首次晋级东部决赛。东部决赛他们面对到的对手是底特律活塞队，活塞已连续第四年都至少打进东部决赛，并曾在2004年拿过总冠军。 骑士队前两战在客场皆以76比79落败，但最后他们在第六战以98比82胜出，连胜四场晋级总决赛。 其中骑士对活塞G5是勒布朗职业生涯的高光时刻，也是后来人们讨论最多的比赛之一，本场比赛勒布朗33投18中，全场砍下48分9板7助的数据，勒布朗末节得到11分，双加时各得到9分包揽球队全部得分。此役，勒布朗包揽球队最后的25分，最终骑士以109：107险胜活塞。 这是一场震撼了联盟的比赛，可以说从这一刻开始，勒布朗加入了联盟第一人的讨论范畴。此时，仅仅是他第四个赛季。 在总决赛中，面对的对手是圣安东尼奥马刺队，最后骑士遭到马刺直落四场横扫击败，此冠军战也创下了历年来转播收视次低纪录，被誉为最难看的冠军赛之一。面对巨大的实力差距，骑士队显得无所适从，但没有人去苛责勒布朗，他依然是克城的英雄。 这轮系列赛诞生了著名的“未来是你的，谢谢你把冠军借给我。” 2007-2008赛季2008年，勒布朗连续4年入选东部明星队。他成为比赛中的最有价值球员，以27分、8个篮板、9个助攻、2个抢断及2个盖帽协助东部，以134-128击败西部。 2008年2月27日，勒布朗在对波士顿凯尔特人的比赛中，取得了个人生涯的第1万分。他仅以23岁59天，成为最年轻达成1万分的球员（旧记录是科比·布莱恩特的24岁159天）。 3月21日对多伦多猛龙的比赛中，取得29分，取代布拉德·多赫蒂成为骑士队总得分最高的球员，以10414分超过多赫蒂的10389分。勒布朗是2007-08球季常规赛平均得分最高的球员，不过在常规赛MVP不敌科比·布莱恩特和克里斯·保罗之下得第三。但成为了NBA的得分王。 勒布朗以45胜37负成绩带领球队晋身季后赛，在第一轮面对老对手华盛顿奇才，以总场数4-2击败对手。 在第二轮面对波士顿凯尔特人，骑士迫使凯尔特人进入第七场比赛，并与皮尔斯对飙，分别砍下41分与45分，但始终是更好的球队赢得胜利，最终更加整体的凯尔特人以4:3的比分将骑士送回家。 那一年的凯尔特人不可阻挡，是科比口中的“super team”，最终凯尔特人以4:2的比分轻取湖人，加内特、皮尔斯、雷阿伦取得了自己垂涎已久的总冠军戒指。 2008-2009赛季2009年2月15日“OK组合”共同获得全明星MVP。 2009年2月20日勒布朗·詹姆斯取得55分协助球队击败密尔沃基雄鹿。在3月10日至13日，连续三场赛事取得三双成绩。3月25日骑士击败篮网后，66胜，取得自成立队以来最好的成绩。 勒布朗·詹姆斯成为常规赛最有价值球员。亦首次进入NBA防守一队。在季后赛，带领骑士队以不败的姿态击退底特律活塞及亚特兰大老鹰率先晋身东部决赛，对手是奥兰多魔术。 对阵魔术G2，在特科格鲁命中关键球后，勒布朗迎着防守投进绝杀，以96:95将比分扳为1-1平。但实力不济，4:2，勒布朗又一次结束了争冠之旅。 当年的魔兽还是联盟中数一数二的防守大闸，所有人都看好他日后可以成为联盟第一中锋，奈何… 至此，骑士队拥有了MVP球员。但勒布朗单核带队的言论不绝于耳，以及上赛季加内特说的“别让忠诚害了你”，开始埋下伏笔。 2009-2010赛季詹姆斯连续六次参加NBA明星赛，更连续三年取得250万票。德怀恩·韦德取得全明星MVP。 詹姆斯成功带领骑士以东部首名跻身季后赛，成为常规赛最有价值球员。第一轮顺利淘汰芝加哥公牛队。 季后赛第二轮的对手是波士顿凯尔特人，其中第五场14投三中取得15分。虽然第六场赛事取得季后赛第六个三双，但仍以85-94不敌波士顿凯尔特人而遭淘汰出局。 糟糕的表现，无望的等待，似乎都在预示着什么。 2010年7月8日，勒布朗通过ESPN举办的全国直播特别节目“The Decision”宣布与热火队签约，将与德怀恩·韦德和克里斯·波什组成热火三巨头。 臭名昭著的“决定一”将勒布朗在舆论上推向深渊。他成为了当时全世界范围内最不受欢迎的运动员。 创下了前一季MVP转队纪录，目前还是历史唯一一人。 大量骑士球迷为之愤怒，他们开始焚烧勒布朗的球衣，似乎无论怎么做都难以熄灭心头的怒火。 虽然勒布朗后来解释道:「电视直播关乎公益」 「热火是一支上赛季还在挣扎的球队」 但无论什么样的解释在这样的事实面前都显得苍白无力。勒布朗选择了更为轻松的争冠之路，将克城推入无尽的深渊。 勒布朗知道克利夫兰是极小的球市，想要等来全明星加盟希望渺茫。但在勒布朗之前，一人一城是许多球迷的信仰，显得尤为珍贵，如果坚守，即使最终勒布朗未能夺冠在茫茫的历史长河中也是一段美谈。 他不甘于做无冕之王，他知道如果未能加冕，没有资格与历史上那些巨星比较，更别说他的目标从一开始就是GOAT。他知道现在自己的身体状态极佳，如果需要冠军从现在起必须开始行动了。 但他不知道在许多球迷心目中他从这一刻起就失去了与神同行的资格。可怜又可悲，如果从一开始勒布朗就属于波士顿、洛杉矶、纽约也许就会一人一城，因为他知道他会等来全明星的加盟，他的球队会保持夺冠竞争力。没有如果，既然做不了下一个神，就做第一个自己吧。 夺冠之路2010-2011赛季詹姆斯第七次入选明星赛，并砍下三双，但东部明星队告负，科比·布莱恩特取得全明星MVP。 2011年12月3日，热火做客克利夫兰，毫无意外迎接勒布朗的是铺天盖地的嘘声与谩骂，勒布朗增加保镖以保证安全。对阵老东家他取得了38分、5个篮板和8次助攻，热火队118比90击败骑士。 12月25日，热火在圣诞大战中战胜湖人。这是一个转折点，多年以来联盟造势的23vs24重心偏移(虽然此时勒布朗已经身披6号战袍)，从这里开始勒布朗似乎渐渐从科比手中接过联盟第一人的称号。 季后赛之旅似乎和想象中一样顺利，热火先是4:1送凯尔特人回家，又一个4:1送新科MVP回家。 故事不会那么完美，总决赛对阵达拉斯小牛G4，勒布朗迷失了自我，全场11投仅3中，得到8分，创造了个人职业生涯季后赛最低得分。最终4:2老司机捧得奥布莱恩杯。这轮系列赛是勒布朗职业生涯挥不去的阴霾，数场比赛第四节的疲软至今都在被人讨论，GOAT只会输给对手，不会输给自己，勒布朗没有准备好赢得最高荣誉，压力与谩骂同时赶到，这一刻他像个罪人。乔丹也离他越来越远。 经历了地狱般的两个赛季，勒布朗好像从天选之子沦为千古罪人。 休赛期，勒布朗开始增重，提升背部力量，同时苦练罚球，他知道如何去赢，他也知道之后的路是完成对自己的救赎。 2011-2012赛季勒布朗第八次入选明星赛，和凯文·杜兰特同时得到全场的最高分36分以及6个篮板和7次助攻。勒布朗至今8次明星赛共得207分，平均25.9分史上最高。杜兰特获得MVP。 像是命运的安排，东决勒布朗再次面对老对手凯尔特人，并且输掉了天王山。此时勒布朗的背后是千夫所指，全世界都在等着看他的笑话，普通人根本无法想象他当时所承受的压力，毫不夸张的说，G6是6vsALL。 绿军的球迷充满敌意，在热火球队大巴前往球场的路上，敌对的球迷甚至立起来广告牌国骂伺候。 再次站在The Garden，勒布朗杀神附体，仅上半场就攻下30分，全场攻下45分摘下15个篮板，一己之力把北岸花园打的鸦雀无声，他进球后面无表情没有庆祝，不在沉默中爆发就在沉默中灭亡，这场比赛让勒布朗得以从泥潭中探出头来，喘上一口气。并且在抢七中赢下比赛，与雷霆会师总决赛。同时死亡之瞳成为了勒布朗的标签之一。 如果让我选择一场比赛来代表勒布朗，我会毫不犹豫的选择这一场。 他主宰了自己的命运，能看到这样的他真的很幸福。 总决赛，面对青年军雷霆，噱头自然是三巨头vs雷霆三少。热火在首场败下阵来，然后直落四局，其中詹姆斯于第四场在大腿抽筋的情况下重新回到场上并投进领先三分球，成为此系列的经典镜头之一。4:1的比分，热火三巨头捧得了奥布莱恩杯，勒布朗加冕FMVP。 其实赢下这轮系列赛并没有比分看上去那么容易，江山代有才人出，年轻的KD，威少，哈登们仿佛在告诉03一代，小心点，我们来了。 **场外:**这年詹姆斯取消经营了所有的社群网站，专心在篮球上面，最后赢得第一座总冠军。 2012-2013赛季2013年1月16日，对战金州勇士队，全场取得25分、10次助攻，达成生涯得分20000分加5000次助攻，取代科比·布莱恩特（29岁122天），成为NBA史上最年轻的20000分球员（28岁又17天）。 全明星赛，科比获得MVP。 詹姆斯率领球队在2月3日-3月25日缔造了NBA史上第二长的27连胜，他在连胜期间的平均数据是优异的27.0分、8.1篮板、8.0助攻、1.9抢断、57.5%命中率。 最终热火队在本赛季创下了队史最佳的单季66胜，也取得了每一轮季后赛的主场优势。热火分别以4:0、4:1击败雄鹿、公牛进入东决。 热火对阵步行者，保罗·乔治领衔步行者将热火拖入抢七。这轮系列赛的主角无疑是泡椒，这些后起之秀也标志着NBA进入了下一个时代，勒布朗成为了媒体公认的联盟第一人。这个时代，名为LBJ。 总决赛面对老辣的马刺，勒布朗外线失准，一路苦战，他们再次输掉了天王山。 G6，凭借雷·阿伦神奇的三分球，热火将比赛拖入加时。最终4:3击败马刺。两连冠。 2013-2014赛季全明星赛，凯里·欧文获得MVP。 赛季结束后，詹姆斯率领球队以东部第二种子晋级季后赛，以4:0和4:1接连击败山猫和篮网，连续四年晋级东部决赛。东部决赛以4:2击败步行者，连续4年赢得东部冠军更闯进总决赛，但总冠军赛以1:4输给马刺。 这年金州勇士拿到了51胜。 兑现承诺2014-2015赛季2014年7月11日，勒布朗跳出合同成为自由球员。向球迷写文章检讨自己的错误，返乡正式宣布将回到职业生涯的起点克利夫兰骑士。与克利夫兰骑士签下2年4221.7万美元合同，第二年为球员选择权。 克城球迷似乎很快就原谅了他，勒布朗再次成为克利夫兰的标志。 全明星赛，威少获得MVP。 经过一整个赛季的磨合，詹姆斯成功带领骑士队以东部第二杀入季后赛。虽然在于季后赛首轮对上凯尔特人的比赛当中，骑士队失去了主将凯文·乐福，不过在骑士队仍然众将发威之下4:0淘汰对手。 东部半决赛中，虽然让对手芝加哥公牛取得了2:1的优势，不过在第四战的最后关头，勒布朗投出了致胜绝杀扳平了战局，最后以4:2成功淘汰对手。并在东部决赛中横扫老鹰。 总决赛对阵勇士，因为欧文和乐福无法上场，骑士2:4不敌勇士。勇士王朝序幕拉开。 2015-2016赛季骑士以57胜25败连庄中央区龙头，季后赛第一轮直落4横扫重返季后赛的底特律活塞，接着在东部半决赛直落4横扫老鹰（其中第2战更轰进25颗三分球，刷新纪录），继2009年之后成为第五组前两轮季后赛8连胜。 东部决赛，骑士碰上猛龙。最终以4:2在东部封王，勒布朗成为史上第8位连续6年挺进总冠军赛的球员。 总决赛面对73胜勇士，几乎没人看好骑士可以夺冠。比赛走向也像赛前预测的一样，很快骑士以1:3落后。 G5勒布朗与欧文同时砍下41分，G6勒布朗再次砍下41分将勇士拖进抢七。 我们都知道这是他的球队。这是他的人。这是支克里夫兰勒布朗-詹姆斯队。 欧文45度角的致胜三分和勒布朗回防的追身大帽至今深深刻在克城人民心中。Cleveland，This is for you. NBA史上，从未有过总决赛1比3落后的大逆转——我们看见了。 NBA史上，从未有过总决赛单场双人40分——我们看见了。 NBA历史上第三次有人总决赛第七场拿三双，第四个人连续两场40+，乔丹、鲨鱼和邓肯之后又一个三度总决赛MVP——我们看见了。 The Chosen One 终于为克城带来了冠军，从此，他将先前的诅咒一笔勾销，背负着不世的惊险、光荣与传说，回家了。 “这是我的动力，我在追逐一个人的幽灵，一个在芝加哥打过球的幽灵。”勒布朗在接受体育画报采访时说 2016-2017赛季骑士于12月11日主场迎战夏洛特黄蜂，勒布朗全场攻下本季新高44分，116：105抢下4连胜。出手24次进17球（包括5记外线），攻下44分、9篮板、10助攻、3抢断。这是他生涯第9次单场至少“40分、10助攻”，追平“篮球之神”Michael Jordan，并列史上第5。另外，詹姆斯完成生涯第7000次助攻，成为史上第一位生涯累积破2.7万分、7000助攻、7000篮板的球员。 从进入联盟以来，勒布朗就是记录收割机，虽然他自己说自己不是一个得分手，但所有关于得分的记录，你都能在排行榜上看到他。 这个赛季，勒布朗连续7年闯入总决赛，也是骑勇第三次对决。 骑士一直在扮演挑战者的角色，这一次他们失败了，勇士成功复仇，以4:1的比分干净利落的赢下了系列赛。也让世人惊讶于勇士的强大。说真的我从未见过如此强大的球队，即使是09年的凯尔特人我觉得也不能与这样的勇士一战。 斯蒂芬·库里将篮球带入了新的纪元，勇士王朝诞生。 2017-2018赛季这个赛季，是最令我动容的一个赛季。 休赛期，欧文出走凯尔特人，对骑士来说这无疑是重伤。 2018年1月23日，骑士虽然114-102不敌圣安东尼奥马刺，但勒布朗成为了NBA历史上第7位球员达到30,000分。以33岁又24天的时间，成为拿到30,000分的最年轻球员，超越科比·布莱恩特的34岁又104天。 2018年2月19日，明星赛开打，由勒布朗队对上斯蒂芬队，勒布朗拿下全场最高29分，包括最后34.5秒得分逆转战局，率队以148比145击败库里领衔的队伍，赛后第3度获封明星赛MVP。 2018年3月31日，骑士主场迎战鹈鹕，勒布朗攻下27分，生涯连续867场比赛缴出双位数得分，超越“篮球之神”Michael Jordan，成为史上第一。 本赛季勒布朗打满了82场常规赛，场均出场37分钟，想要把全部能量留在场上。 季后赛之路无比艰险，上一次勒布朗在首轮就打的如此挣扎还是骑士1.0时代。 步行者凭借着新领袖奥拉迪波的出色发挥首轮就将骑士拖入抢七。 东决面对宿敌凯尔特人，欧文受伤未出战，但年轻的凯尔特人展现出了无比坚韧的态度，骑士举步维艰，甚至大家普遍认为凯尔特人可以赢下系列赛。 G7勒布朗打满了48分钟，最后一攻一防尽显王者本色，将骑士带进了总决赛。同时也是他自己连续第8次进入总决赛。 赛后勒布朗说：”我感觉我的身体快要烧着了” 王城已破，皇宫已倒，只有国王还坐在王位上。 整个东部都在等着勒布朗老去。 总决赛，这本该是毫无悬念的系列赛。骑士并不足以撼动勇士王朝。 G1勒布朗从第一节开始发动攻击模式，仿佛回到了2012，51分，却不足以掰下勇士的獠牙，但我们都知道，勒布朗尽力了，这样的表现配得上伟大二字。 勇士直落四局再次卫冕。KD再次证明了收割能力，荣膺FMVP。 新的旅程2018年夏天，勒布朗再一次离开了克城。 这一次，没有电视直播没有媒体炒作，勒布朗作出决定之干脆仿佛早已准备好了一切。 I Promise 问世。这是勒布朗留给克城最大的礼物。也是勒布朗给自己最好的礼物。 这一次，克城人民没有了上一次勒布朗离开时的愤怒，我们都知道，在场上，他倾其所有，在场下，他帮助克利夫兰走向繁荣，在克城人民心中他是英雄。 毫无疑问，这不是最传奇的职业生涯。对于勒布朗的评价也是褒贬不一。但我们都知道，如此之多批评的声音是因为勒布朗早早加入了联盟第一人的讨论，现在又加入了总统山的讨论。讨厌他的人觉得他做什么都是错。 9年总决赛6个亚军，他显然不是个合格的赢家。 巅峰之年出走迈阿密，他不是个英雄。 不敌小牛，“咳嗽门”，他输给了对手更是输给了自己。 自带体系，拥有勒布朗的球队就是勒布朗队，队友要融入体系而无法改变体系。 另一方面。 虽然是历史级别的天赋，但也是历史级别的兑现天赋。 有勒布朗的队伍都拥有历史级别的防守反击能力。他本人更是历史第一2+0。 以他大包大揽的打法，很难想象他的巅峰期如此之长，并且很少受伤，这背后是什么不言而喻。 除此之外。 他的商业头脑更是享誉联盟。从阿克伦一路走来，他的野心之大，思路之清晰让人叹为观止。但他没有迷失自己，全心全意投身慈善。身体力行帮助家乡发展。 他可能真的没有那么招人喜欢，但显然是个合格的榜样。正如他自己所说： Love me or Hate me but at the end of day U will respect me. 然而。他的职业生涯还没结束。 2018年11月15日，勒布朗在主场对开拓者比赛中狂飙44分10篮板9助攻生涯累积得分达到31425分，一举超越张伯伦独居史上第5。 总得分排行榜前4名分别是：贾巴尔（Kareem Abdul-Jabbar，38387分）、马龙（Karl Malone，36928分）、布莱恩特（Kobe Bryant，33643分）、乔丹（Michael Jordan，32292分）。","categories":[{"name":"hobby","slug":"hobby","permalink":"https://yoonalim.github.io/categories/hobby/"}],"tags":[{"name":"NBA","slug":"NBA","permalink":"https://yoonalim.github.io/tags/NBA/"}]},{"title":"JavaClassLoader","slug":"JavaClassLoader","date":"2018-12-06T09:57:29.000Z","updated":"2022-08-29T01:28:27.475Z","comments":true,"path":"2018/12/06/JavaClassLoader/","link":"","permalink":"https://yoonalim.github.io/2018/12/06/JavaClassLoader/","excerpt":"","text":"ClassLoader做什么的？ 顾名思义，它是用来加载Class的。它负责将Class的字节码形式转换成内存形式的Class对象。字节码可以来自于磁盘文件*.class，也可以是jar包里的*.class，也可以来自远程服务器提供的字节流，字节码的本质就是一个字节数组[]byte，它有特定的复杂的内部格式。 有很多字节码加密技术就是依靠定制ClassLoader来实现的。先使用工具对字节码文件进行加密，运行时使用定制的ClassLoader先解密文件内容再加载这些解密后的字节码。 每个Class对象的内部都有一个classLoader字段来标识自己是由哪个ClassLoader加载的。ClassLoader就像一个容器，里面装了很多已经加载的Class对象。 12345classClass&lt;T&gt; &#123; ... privatefinalClassLoaderclassLoader; ...&#125; 延迟加载 JVM运行并不是一次性加载所需要的全部类的，它是按需加载，也就是延迟加载。程序在运行的过程中会逐渐遇到很多不认识的新类，这时候就会调用ClassLoader来加载这些类。加载完成后就会将Class对象存在ClassLoader里面，下次就不需要重新加载了。 比如你在调用某个类的静态方法时，首先这个类肯定是需要被加载的，但是并不会触及这个类的实例字段，那么实例字段的类别Class就可以暂时不必去加载，但是它可能会加载静态字段相关的类别，因为静态方法会访问静态字段。而实例字段的类别需要等到你实例化对象的时候才可能会加载。 各司其职 JVM运行实例中会存在多个ClassLoader，不同的ClassLoader会从不同的地方加载字节码文件。它可以从不同的文件目录加载，也可以从不同的jar文件中加载，也可以从网络上不同的服务地址来加载。 JVM中内置了三个重要的ClassLoader，分别是BootstrapClassLoader、ExtensionClassLoader和AppClassLoader。 BootstrapClassLoader 负责加载JVM运行时核心类，这些类位于JAVA_HOME/lib/rt.jar文件中，我们常用内置库java.xxx.*都在里面，比如java.util.*、java.io.*、java.nio.*、java.lang.*等等。这个ClassLoader比较特殊，它是由C代码实现的，我们将它称之为「根加载器」。 ExtensionClassLoader 负责加载VM扩展类，比如swing系列、内置的js引擎、xml解析器等等，这些库名通常以javax开头，它们的jar包位于JAVA_HOME/lib/ext/*.jar中，有很多jar包。 AppClassLoader 才是直接面向我们用户的加载器，它会加载Classpath环境变量里定义的路径中的jar包和目录。我们自己编写的代码以及使用的第三方jar包通常都是由它来加载的。 那些位于网络上静态文件服务器提供的jar包和class文件，jdk内置了一个URLClassLoader，用户只需要传递规范的网络路径给构造器，就可以使用URLClassLoader来加载远程类库了。URLClassLoader不但可以加载远程类库，还可以加载本地路径的类库，取决于构造器中不同的地址形式。ExtensionClassLoader和AppClassLoader都是URLClassLoader的子类，它们都是从本地文件系统里加载类库。 AppClassLoader可以由ClassLoader类提供的静态方法getSystemClassLoader()得到，它就是我们所说的「系统类加载器」，我们用户平时编写的类代码通常都是由它加载的。当我们的main方法执行的时候，这第一个用户类的加载器就是AppClassLoader。 ClassLoader传递性 程序在运行过程中，遇到了一个未知的类，它会选择哪个ClassLoader来加载它呢？虚拟机的策略是使用调用者Class对象的ClassLoader来加载当前未知的类。何为调用者Class对象？就是在遇到这个未知的类时，虚拟机肯定正在运行一个方法调用（静态方法或者实例方法），这个方法挂在哪个类上面，那这个类就是调用者Class对象。前面我们提到每个Class对象里面都有一个classLoader属性记录了当前的类是由谁来加载的。 因为ClassLoader的传递性，所有延迟加载的类都会由初始调用main方法的这个ClassLoader全全负责，它就是AppClassLoader。 双亲委派 前面我们提到AppClassLoader只负责加载Classpath下面的类库，如果遇到没有加载的系统类库怎么办，AppClassLoader必须将系统类库的加载工作交给BootstrapClassLoader和ExtensionClassLoader来做，这就是我们常说的「双亲委派」。 AppClassLoader在加载一个未知的类名时，它并不是立即去搜寻Classpath，它会首先将这个类名称交给ExtensionClassLoader来加载，如果ExtensionClassLoader可以加载，那么AppClassLoader就不用麻烦了。否则它就会搜索Classpath。 而ExtensionClassLoader在加载一个未知的类名时，它也并不是立即搜寻ext路径，它会首先将类名称交给BootstrapClassLoader来加载，如果BootstrapClassLoader可以加载，那么ExtensionClassLoader也就不用麻烦了。否则它就会搜索ext路径下的jar包。 这三个ClassLoader之间形成了级联的父子关系，每个ClassLoader都很懒，尽量把工作交给父亲做，父亲干不了了自己才会干。每个ClassLoader对象内部都会有一个parent属性指向它的父加载器。 12345classClassLoader &#123; ... privatefinalClassLoaderparent; ...&#125; 值得注意的是图中的ExtensionClassLoader的parent指针画了虚线，这是因为它的parent的值是null，当parent字段是null时就表示它的父加载器是「根加载器」。如果某个Class对象的classLoader属性值是null，那么就表示这个类也是「根加载器」加载的。 Class.forName 当我们在使用jdbc驱动时，经常会使用Class.forName方法来动态加载驱动类。 Class.forName(\"com.mysql.cj.jdbc.Driver\");其原理是mysql驱动的Driver类里有一个静态代码块，它会在Driver类被加载的时候执行。这个静态代码块会将mysql驱动实例注册到全局的jdbc驱动管理器里。 class Driver &#123; static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125; &#125; ... &#125; forName方法同样也是使用调用者Class对象的ClassLoader来加载目标类。不过forName还提供了多参数版本，可以指定使用哪个ClassLoader来加载Class forName(String name, boolean initialize, ClassLoader cl)通过这种形式的forName方法可以突破内置加载器的限制，通过使用自定类加载器允许我们自由加载其它任意来源的类库。根据ClassLoader的传递性，目标类库传递引用到的其它类库也将会使用自定义加载器加载。 自定义加载器 ClassLoader里面有三个重要的方法loadClass()、findClass()和defineClass()。 loadClass()方法是加载目标类的入口，它首先会查找当前ClassLoader以及它的双亲里面是否已经加载了目标类，如果没有找到就会让双亲尝试加载，如果双亲都加载不了，就会调用findClass()让自定义加载器自己来加载目标类。ClassLoader的findClass()方法是需要子类来覆盖的，不同的加载器将使用不同的逻辑来获取目标类的字节码。拿到这个字节码之后再调用defineClass()方法将字节码转换成Class对象。下面我使用伪代码表示一下基本过程 class ClassLoader &#123; // 加载入口，定义了双亲委派规则 Class loadClass(String name) &#123; // 是否已经加载了 Class t = this.findFromLoaded(name); if(t == null) &#123; // 交给双亲 t = this.parent.loadClass(name) &#125; if(t == null) &#123; // 双亲都不行，只能靠自己了 t = this.findClass(name); &#125; return t; &#125; // 交给子类自己去实现 Class findClass(String name) &#123; throw ClassNotFoundException(); &#125; // 组装Class对象 Class defineClass(byte[] code, String name) &#123; return buildClassFromCode(code, name); &#125; &#125; class CustomClassLoader extends ClassLoader &#123; Class findClass(String name) &#123; // 寻找字节码 byte[] code = findCodeFromSomewhere(name); // 组装Class对象 return this.defineClass(code, name); &#125; &#125; 自定义类加载器不易破坏双亲委派规则，不要轻易覆盖loadClass方法。否则可能会导致自定义加载器无法加载内置的核心类库。在使用自定义加载器时，要明确好它的父加载器是谁，将父加载器通过子类的构造器传入。如果父类加载器是null，那就表示父加载器是「根加载器」。 // ClassLoader 构造器 protected ClassLoader(String name, ClassLoader parent); 双亲委派规则可能会变成三亲委派，四亲委派，取决于你使用的父加载器是谁，它会一直递归委派到根加载器。 Class.forName vs ClassLoader.loadClass 这两个方法都可以用来加载目标类，它们之间有一个小小的区别，那就是 Class.forName() 方法可以获取原生类型的 Class，而 ClassLoader.loadClass() 则会报错。 Class x = Class.forName(\"[I\"); System.out.println(x); x = ClassLoader.getSystemClassLoader().loadClass(\"[I\"); System.out.println(x); --------------------- class [I Exception in thread \"main\" java.lang.ClassNotFoundException: [I ... 钻石依赖 项目管理上有一个著名的概念叫着「钻石依赖」，是指软件依赖导致同一个软件包的两个版本需要共存而不能冲突。 我们平时使用的 maven 是这样解决钻石依赖的，它会从多个冲突的版本中选择一个来使用，如果不同的版本之间兼容性很糟糕，那么程序将无法正常编译运行。Maven 这种形式叫「扁平化」依赖管理。 使用 ClassLoader 可以解决钻石依赖问题。不同版本的软件包使用不同的 ClassLoader 来加载，位于不同 ClassLoader 中名称一样的类实际上是不同的类。下面让我们使用 URLClassLoader 来尝试一个简单的例子，它默认的父加载器是 AppClassLoader $ cat ~/source/jcl/v1/Dep.java public class Dep &#123; public void print() &#123; System.out.println(\"v1\"); &#125; &#125; $ cat ~/source/jcl/v2/Dep.java public class Dep &#123; public void print() &#123; System.out.println(\"v1\"); &#125; &#125; $ cat ~/source/jcl/Test.java public class Test &#123; public static void main(String[] args) throws Exception &#123; String v1dir = \"file:///Users/MaijiaGod/source/jcl/v1/\"; String v2dir = \"file:///Users/MaijiaGod/source/jcl/v2/\"; URLClassLoader v1 = new URLClassLoader(new URL[]&#123;new URL(v1dir)&#125;); URLClassLoader v2 = new URLClassLoader(new URL[]&#123;new URL(v2dir)&#125;); Class depv1Class = v1.loadClass(\"Dep\"); Object depv1 = depv1Class.getConstructor().newInstance(); depv1Class.getMethod(\"print\").invoke(depv1); Class depv2Class = v2.loadClass(\"Dep\"); Object depv2 = depv2Class.getConstructor().newInstance(); depv2Class.getMethod(\"print\").invoke(depv2); System.out.println(depv1Class.equals(depv2Class)); &#125; &#125; 在运行之前，我们需要对依赖的类库进行编译 12345678910$ cd ~/source/jcl/v1$ javac Dep.java$ cd ~/source/jcl/v2$ javac Dep.java$ cd ~/source/jcl$ javac Test.java$ java Testv1v2false 在这个例子中如果两个 URLClassLoader 指向的路径是一样的，下面这个表达式还是 false，因为即使是同样的字节码用不同的 ClassLoader 加载出来的类都不能算同一个类 depv1Class.equals(depv2Class) 我们还可以让两个不同版本的 Dep 类实现同一个接口，这样可以避免使用反射的方式来调用 Dep 类里面的方法。 Classdepv1Class=v1.loadClass(\"Dep\"); IPrintdepv1=(IPrint)depv1Class.getConstructor().newInstance(); depv1.print() ClassLoader固然可以解决依赖冲突问题，不过它也限制了不同软件包的操作界面必须使用反射或接口的方式进行动态调用。Maven没有这种限制，它依赖于虚拟机的默认懒惰加载策略，运行过程中如果没有显示使用定制的ClassLoader，那么从头到尾都是在使用AppClassLoader，而不同版本的同名类必须使用不同的ClassLoader加载，所以Maven不能完美解决钻石依赖。如果你想知道有没有开源的包管理工具可以解决钻石依赖的，我推荐你了解一下sofa-ark，它是蚂蚁金服开源的轻量级类隔离框架。 分工与合作 这里我们重新理解一下ClassLoader的意义，它相当于类的命名空间，起到了类隔离的作用。位于同一个ClassLoader里面的类名是唯一的，不同的ClassLoader可以持有同名的类。ClassLoader是类名称的容器，是类的沙箱。 不同的ClassLoader之间也会有合作，它们之间的合作是通过parent属性和双亲委派机制来完成的。parent具有更高的加载优先级。除此之外，parent还表达了一种共享关系，当多个子ClassLoader共享同一个parent时，那么这个parent里面包含的类可以认为是所有子ClassLoader共享的。这也是为什么BootstrapClassLoader被所有的类加载器视为祖先加载器，JVM核心类库自然应该被共享。 Thread.contextClassLoader 如果你稍微阅读过 Thread 的源代码，你会在它的实例字段中发现有一个字段非常特别 class Thread &#123; ... private ClassLoader contextClassLoader; public ClassLoader getContextClassLoader() &#123; return contextClassLoader; &#125; public void setContextClassLoader(ClassLoader cl) &#123; this.contextClassLoader = cl; &#125; ... &#125; contextClassLoader「线程上下文类加载器」，这究竟是什么东西？ 首先 contextClassLoader 是那种需要显示使用的类加载器，如果你没有显示使用它，也就永远不会在任何地方用到它。你可以使用下面这种方式来显示使用它 Thread.currentThread().getContextClassLoader().loadClass(name); 这意味着如果你使用 forName(string name) 方法加载目标类，它不会自动使用 contextClassLoader。那些因为代码上的依赖关系而懒惰加载的类也不会自动使用 contextClassLoader来加载。 其次线程的contextClassLoader是从父线程那里继承过来的，所谓父线程就是创建了当前线程的线程。程序启动时的main线程的contextClassLoader就是AppClassLoader。这意味着如果没有人工去设置，那么所有的线程的contextClassLoader都是AppClassLoader。 那这个 contextClassLoader 究竟是做什么用的？我们要使用前面提到了类加载器分工与合作的原理来解释它的用途。 它可以做到跨线程共享类，只要它们共享同一个 contextClassLoader。父子线程之间会自动传递 contextClassLoader，所以共享起来将是自动化的。 如果不同的线程使用不同的 contextClassLoader，那么不同的线程使用的类就可以隔离开来。 如果我们对业务进行划分，不同的业务使用不同的线程池，线程池内部共享同一个 contextClassLoader，线程池之间使用不同的 contextClassLoader，就可以很好的起到隔离保护的作用，避免类版本冲突。 如果我们不去定制 contextClassLoader，那么所有的线程将会默认使用 AppClassLoader，所有的类都将会是共享的。 线程的 contextClassLoader 使用场合比较罕见，如果上面的逻辑晦涩难懂也不必过于计较。 JDK9 增加了模块功能之后对类加载器的结构设计做了一定程度的修改，不过类加载器的原理还是类似的，作为类的容器，它起到类隔离的作用，同时还需要依靠双亲委派机制来建立不同的类加载器之间的合作关系。","categories":[{"name":"basic","slug":"basic","permalink":"https://yoonalim.github.io/categories/basic/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://yoonalim.github.io/tags/Java/"}]},{"title":"关于[angularjs] ng_select和ng_option","slug":"关于-angularjs-ng-select和ng-option","date":"2018-02-08T08:42:23.000Z","updated":"2022-08-29T01:31:03.895Z","comments":true,"path":"2018/02/08/关于-angularjs-ng-select和ng-option/","link":"","permalink":"https://yoonalim.github.io/2018/02/08/%E5%85%B3%E4%BA%8E-angularjs-ng-select%E5%92%8Cng-option/","excerpt":"","text":"身为一个后端开发，也难免要搞点前端的事情。 最近在开发一个小功能的时候发现需要页面实现三级联动，由于前端用的是angular所以被迫了解了一下。 不得不承认，angularjs还是比较容易上手，里面很多地方都让人不禁感叹，牛逼！牛逼！ 由于我只是记录学习过程中用到的东西，并不打算做什么教程，所以闲话就少说了，直接来干货。 由于之前已经有类似接口可以给我提供数据，返回的数据接口如因为我认为返回数据格式完全可以支持三级联动，于是我上网查了下anglar如何实现三级联动(这里不放链接了，一搜一大把)。然后我发现了ng-select。 ng-select用来将数据同HTML的&lt; select&gt;进行绑定。这个指令可以和ng-model以及ng-options指令一起使用，构建精细且表现良好的动态表单。 ng-options的值可以是一个内涵表达式（comprehension expression），其实这只是一种有趣的说法，简单来说就是它可以接收一个数组或者对象，并对她们进行循环，将内部的内容提供给select标签内部的选项。ng-options有以下格式的语法 for array data sources: label for value in array select as label for value in array label group by group for value in array select as label group by group for value in array track by trackexpr for object data sources: label for (key , value) in object select as label for (key , value) in object label group by group for (key, value) in object select as label group by group for (key, value) in ob 经过一小会er的思考，我将页面代码写成然后惊喜的发现已经成功了，在感叹angular强大的同时也默默自满了一下。在页面上的效果是这样的 然后查看一下dom 会发现，上面的option中的text都是对象，这也很容易理解，因为stockList数组的每一项都是一个对象，绑定的时候将以对象直接绑定上。那么我们如何只让它显示text属性呢？ angular告诉我们，直接点出属性即可：x.text for x in object.property 接下来就涉及到双向绑定。这里已经指定了ng-model，获取选中的值，也非常方便了。由于代码是我修改完发出来的，所以上文中可以查看代码图片，就不过多解释了。 之后在js中用angular.copy将object返显出来，就达到目的啦。 总结一下。三级联动的实现主要靠函数表达式来实现，但这种表达式反选会出现问题，导致数据不能返显，所以要依靠ng-change记录表单变化来实现返显。","categories":[{"name":"skills","slug":"skills","permalink":"https://yoonalim.github.io/categories/skills/"}],"tags":[{"name":"AngularJs","slug":"AngularJs","permalink":"https://yoonalim.github.io/tags/AngularJs/"}]},{"title":"终极shell ZSH","slug":"zsh","date":"2018-01-11T08:15:35.000Z","updated":"2022-08-29T01:19:48.206Z","comments":true,"path":"2018/01/11/zsh/","link":"","permalink":"https://yoonalim.github.io/2018/01/11/zsh/","excerpt":"","text":"在介绍zsh前，先问两个问题吧： 1、相对于其他系统，Mac 的主要优势是什么？ 2、你平时用哪种 Shell？ …… em…..Mac 的最大优势是 GUI 和命令行的完美结合，不要把所有注意力放在 Mac 性感的腰身和明媚的显示屏上好吧，如果你还在用Windows 的 cmd ，那么也没什么好聊的了。 Shell是Linux&#x2F;Unix的一个外壳，你理解成衣服也行。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。 Linux&#x2F;Unix提供了很多种Shell，为毛要这么多Shell？难道用来炒着吃么？那我问你，你同类型的衣服怎么有那么多件？花色，质地还不一样。写程序比买衣服复杂多了，而且程序员往往负责把复杂的事情搞简单，简单的事情搞复杂。牛程序员看到不爽的Shell，就会自己重新写一套，慢慢形成了一些标准，常用的Shell有这么几种，sh、bash、csh等，想知道你的系统有几种shell，可以通过以下命令查看： 1$ cat /etc/shells 在 Linux 里执行这个命令和 Mac 略有不同，你会发现 Mac 多了一个 zsh，也就是说 OS X 系统预装了个 zsh，这是个神马 Shell 呢？ 目前常用的 Linux 系统和 OS X 系统的默认 Shell 都是 bash，但是真正强大的 Shell 是深藏不露的 zsh， 这货绝对是马车中的跑车，跑车中的飞行车，史称『终极 Shell』，但是由于配置过于复杂，所以初期无人问津，很多人跑过来看看 zsh 的配置指南，什么都不说转身就走了。直到有一天，国外有个穷极无聊的程序员开发出了一个能够让你快速上手的zsh项目，叫做「oh my zsh」,也就是我们今天介绍的~ Github 网址是：https://github.com/robbyrussell/oh-my-zsh。这玩意就像「X天叫你学会 C++」系列，可以让你神功速成，而且是真的。 好，下面我们看看如何安装、配置和使用 zsh。 安装zsh如果你用 Mac，就可以直接看下一节 如果你用 Redhat Linux，执行： 1sudo yum install zsh 如果你用 Ubuntu Linux，执行： 1sudo apt-get install zsh 如果你用 Windows……去洗洗睡吧。 安装完成后设置当前用户使用 zsh： 1chsh -s /bin/zsh 根据提示输入当前用户的密码就可以了。 安装oh my zsh首先安装 git，安装方式同上，把 zsh 换成 git 即可。 安装「oh my zsh」可以自动安装也可以手动安装。 自动安装： 1wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh em…. 这里你可能会 wget:comman not found 那就不多说了，你需要安装一个 **homebrew https://mxcl.github.io/homebrew/**推荐！专门来替代MacPorts 1ruby -e &quot;$(curl -fsSkL http://raw.github.com/mxcl/homebrew/go)&quot; 然后 1brew install wget 现在执行上面的指令，你会发现没有Windows的世界是多么美妙… 手动安装： 12git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshcp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 都不复杂，安装完成之后退出当前会话重新打开一个终端窗口，你就可以见到这个彩色的提示了： 配置zsh 的配置主要集中在用户当前目录的.zshrc里，用 vim 或你喜欢的其他编辑器打开.zshrc，在最下面会发现这么一行字： Customize to your needs… 可以在此处定义自己的环境变量和别名，当然，oh my zsh 在安装时已经自动读取当前的环境变量并进行了设置，你可以继续追加其他环境变量。 接下来进行别名的设置，我自己的部分配置如下： 1234567891011121314151617alias cls=&#x27;clear&#x27;alias ll=&#x27;ls -l&#x27;alias la=&#x27;ls -a&#x27;alias vi=&#x27;vim&#x27;alias javac=&quot;javac -J-Dfile.encoding=utf8&quot;alias grep=&quot;grep --color=auto&quot;alias -s html=mate # 在命令行直接输入后缀为 html 的文件名，会在 TextMate 中打开alias -s rb=mate # 在命令行直接输入 ruby 文件，会在 TextMate 中打开alias -s py=vi # 在命令行直接输入 python 文件，会用 vim 中打开，以下类似alias -s js=vialias -s c=vialias -s java=vialias -s txt=vialias -s gz=&#x27;tar -xzvf&#x27;alias -s tgz=&#x27;tar -xzvf&#x27;alias -s zip=&#x27;unzip&#x27;alias -s bz2=&#x27;tar -xjvf&#x27; zsh 的牛*之处在于不仅可以设置通用别名，还能针对文件类型设置对应的打开程序，比如： alias -s html&#x3D;mate，意思就是你在命令行输入 hello.html，zsh会为你自动打开 TextMat 并读取 hello.html； alias -s gz&#x3D;’tar -xzvf’，表示自动解压后缀为 gz 的压缩包。 总之，只有想不到，没有做不到。 设置完环境变量和别名之后，基本上就可以用了，如果你是个主题控，还可以玩玩 zsh 的主题。在 .zshrc 里找到ZSH_THEME，就可以设置主题了，默认主题是： ZSH_THEME&#x3D;”robbyrussell” oh my zsh 提供了数十种主题，相关文件在~&#x2F;.oh-my-zsh&#x2F;themes目录下，你可以随意选择，也可以编辑主题满足自己的变态需求。 使用zsh1、兼容 bash，原来使用 bash 的兄弟切换过来毫无压力，该咋用咋用。 2、强大的历史纪录功能，输入 grep 然后用上下箭头可以翻阅你执行的所有 grep 命令。 3、智能拼写纠正，输入gtep mactalk * -R，系统会提示：zsh: correct ‘gtep’ to ‘grep’ [nyae]? 比妹纸贴心吧，她们向来都是让你猜的…… 4、各种补全：路径补全、命令补全，命令参数补全，插件内容补全等等。触发补全只需要按一下或两下 tab 键，补全项可以使用 ctrl+n&#x2F;p&#x2F;f&#x2F;b上下左右切换。比如你想杀掉 java 的进程，只需要输入 kill java + tab键，如果只有一个 java 进程，zsh 会自动替换为进程的 pid，如果有多个则会出现选择项供你选择。ssh + 空格 + 两个tab键，zsh会列出所有访问过的主机和用户名进行补全 5、智能跳转，安装了autojump之后，zsh 会自动记录你访问过的目录，通过 j + 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过hadoop-1.0.0目录，输入j hado 即可正确跳转。j –stat 可以看你的历史路径库。 6、目录浏览和跳转：输入 d，即可列出你在这个会话里访问的目录列表，输入列表前的序号，即可直接跳转。 7、在当前目录下输入 .. 或 … ，或直接输入当前目录名都可以跳转，你甚至不再需要输入 cd 命令了。 … 看完这篇文章，你就知道，zsh一出，无人再与争锋！终极二字不是盖的。 如果你是个正在使用 shell程序员，如果你依然准备使用 bash，那就去面壁和忏悔吧。","categories":[{"name":"tools","slug":"tools","permalink":"https://yoonalim.github.io/categories/tools/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://yoonalim.github.io/tags/linux/"},{"name":"mac","slug":"mac","permalink":"https://yoonalim.github.io/tags/mac/"}]}],"categories":[{"name":"log","slug":"log","permalink":"https://yoonalim.github.io/categories/log/"},{"name":"basic","slug":"basic","permalink":"https://yoonalim.github.io/categories/basic/"},{"name":"hobby","slug":"hobby","permalink":"https://yoonalim.github.io/categories/hobby/"},{"name":"skills","slug":"skills","permalink":"https://yoonalim.github.io/categories/skills/"},{"name":"tools","slug":"tools","permalink":"https://yoonalim.github.io/categories/tools/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://yoonalim.github.io/tags/C/"},{"name":"Java","slug":"Java","permalink":"https://yoonalim.github.io/tags/Java/"},{"name":"NBA","slug":"NBA","permalink":"https://yoonalim.github.io/tags/NBA/"},{"name":"AngularJs","slug":"AngularJs","permalink":"https://yoonalim.github.io/tags/AngularJs/"},{"name":"linux","slug":"linux","permalink":"https://yoonalim.github.io/tags/linux/"},{"name":"mac","slug":"mac","permalink":"https://yoonalim.github.io/tags/mac/"}]}